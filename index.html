<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>Player API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Player</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import simpleaudio as sa
from scipy.io import wavfile

from scales import scales

class Player(object):
    # 44100 Hz is one of the standard 
    # wav sampling rates, so we default to this
    def __init__(self, sample_rate = 44100):
        &#34;&#34;&#34;
        Initializes a Player instance, e.g. player = Player()
        &#34;&#34;&#34;
        # This function just uses the first digit of the number to decide
        # the scale degree to play
        self.get_note_from_integer = lambda x: int(x[0])
        self.notes = np.array([])
        self.note_durations = np.array([])
        self.duration = 0
        # 83 Hz is the low E on a gutar in standard tuning
        self.base = 83
        self.audio  = np.array([])
        self.sample_rate = sample_rate
        # To get scale tones, we use equal temperament,
        # where each semitone is reached by multiplying
        # the frequency of a pitch by 2^(1/12). This way,
        # an octaver will have exactly twice the frequency,
        # and the notes in between will be (gemoetrically)
        # evenly spaced. Equal temperament is pretty much
        # THE tuning method used in all of Western music.
        # See https://en.wikipedia.org/wiki/Equal_temperament
        # for more information
        self.semitone = 2 ** (1 / 12)
        self.scales = {}
    
        for scale in scales.keys():
            self.add_scale(name=scale, scale=scales[scale])

        # Defaulting the scale to harmonic minor
        self.active_scale = self.scales[&#34;harmonic minor&#34;]

    def set_base(self, base: int):
        &#34;&#34;&#34;
        Sets the base frequency to
        use for new scales.
        &#34;&#34;&#34;
        self.base = base
        return self.base
    
    def set_get_note(self, function: callable):
        &#34;&#34;&#34;
        Sets the get_note_from_integer function. By default,
        this function just uses the first digit in a number,
        but you can change that by passing set_get_note a function.
        &#34;&#34;&#34;
        self.get_note_from_integer = function
        return self.get_note_from_integer

    def update_duration(self):
        &#34;&#34;&#34;
        When we change the notes or
        the note durations, the total
        duration also changes, so we
        must update it. This happens automatically,
        as update_duration is called in both
        set_notes and set_note_durations.
        &#34;&#34;&#34;
        print(f&#34;len(self.note_durations) = {len(self.note_durations)}&#34;)
        self.duration = sum(self.note_durations)
        return self.duration

    def set_notes(self, notes: list):
        &#34;&#34;&#34;
        Sets the player&#39;s notes
        using the given list.
        &#34;&#34;&#34;
        # Making sure all the notes are integers
        self.notes = notes
        # If the length of self.notes and self.note_durations is not
        # the same, then that probably just means you&#39;ve called
        # either set_notes or set_note_durations but not the other
        # We onlyu want to call update_duration if the lengths are the same,
        # because it will (rightfully) throw an error otherwise.
        if len(self.notes) == len(self.note_durations):
            self.update_duration()
        return self.notes
        
    def set_note_durations(self, durations: list):
        &#34;&#34;&#34;
        Uses the given list to set the
        durations of the notes.
        &#34;&#34;&#34;
        # Making sure note durations are floats
        self.note_durations = np.array(durations).astype(float)
        # See the method declaration of set_notes; we only want to call
        # update_duration if self.notes has the same length as 
        # self.note_durations
        if len(self.notes) == len(self.note_durations):
            self.update_duration()
        return self.note_durations

    def set_active_scale(self, name: str):
        &#34;&#34;&#34;
        Sets the active scale to the
        provided scale name, provided
        the scale exists in self.scales
        &#34;&#34;&#34;
        self.active_scale = self.scales[name]
        return self.active_scale

    def add_scale(self, name: str, scale: list, number_of_octaves: int = 100):
        &#34;&#34;&#34;
        Adds a given scale to the Player
        with the given name,
        e.g. Player().add_scale(&#34;melodic minor&#34;, [*scaletones]).
        &#34;&#34;&#34;
        
        # Here we extend the given scale up to many ovtaves.
        # The default is 100 octaves, but we can go higher
        # if we want to. 100 octaves is proably plenty
        # for most use cases though
        extended_scale = np.array(scale)
        for i in range(1, number_of_octaves):
            octave = self.semitone ** (12 * i)
            extended_scale = np.hstack([
                extended_scale, octave * np.array(scale)
            ])
        self.scales[name] = extended_scale
        return extended_scale
    
    def generate_audio(self, scale: list = None):
        &#34;&#34;&#34;
        Uses the given scale, defaulting to self.active_scale,
        to generate audio from self.notes and self.note_durations,
        then stores it in self.audio.
        &#34;&#34;&#34;
        # Make sure there is a note duration
        # specified for each note       
        try:
            len(self.notes) == len(self.note_durations)
        except:
            raise Exception(&#34;self.notes does not have the same length as self.note_durations&#34;)
        # This loop with the try and except
        # allows the user to input single notes
        # without using a list, e.g. 5 instead of [5]
        for i in range(0, len(self.notes)):
            try:
                len(self.notes[i])
            except:
                self.notes[i] = [self.notes[i]]
        # Default the scale to self.active_scale if
        # no scale is given
        if not scale:
            scale = self.active_scale
        T = []
        frequency = []
        intervals = []

        t = 0
        progress = 0
        # Prints like this and others that come up later in this
        # function are just there to give the user an idea
        # of what is going, on, because this function can
        # take a while to run if you give it a lot of data
        print(&#34;Generating t list and intervals...&#34;)

        # Working out the size of the biggest chord used. This
        # will be useful later in the code
        chord_size = max([len(chord) for chord in self.notes])

        for i in range(0, len(self.notes)):
            # Calculate the percentage progress in the loop
            # and print it out if it is more than 1% more than
            # last time we printed it
            new_progress = (i + 1) / len(self.notes) * 100
            if new_progress - progress &gt;= 1:
                progress = new_progress
                print(f&#34;{int(progress)}%&#34;)
            #################################################

            # This is how many &#39;instances&#39; of the note we need to 
            # cover its duration using our sample rate
            n = int(self.sample_rate * self.note_durations[i])
            # Just stick as many notes as we need into the intervals list
            #intervals.extend(np.full(n, self.notes[i]))
            for j in range(0, n):
                intervals.append(self.notes[i])
            # Increment t n times since we added intervals to the intervals list
            for j in range(0, n):
                T.append(t)
                # 1 over the sample rate
                # is the &#39;smallest possible time&#39;
                # for our melody
                t += 1 / self.sample_rate

        T = np.array(T)
        
        print(&#34;Converting scale intervals to frequencies...&#34;)
        chords = [interval if len(interval) &gt; 0 else [interval] for interval in intervals]
        # This loop pads chords that are smaller than the biggest by simply
        # adding a duplicate. This way we can treat all our chords
        # (even single notes!) exactly the samwe way in our code
        for i in range(0, len(chords)):
            chords[i].extend(np.full(chord_size - len(chords[i]), chords[i][0]))
        frequencies = []
        for chord in chords:
                frequency = np.array([scale[interval] for interval in chord])
                frequencies.append(frequency)

        # Transpoing the frequencies. This will make it much
        # easier to merge together the notes in chords
        # Don&#39;t worry about the shape of the array being messed uo
        # now, as we will transpose it back again whenevr
        # we save the audio to a file (in save_audio)
        frequencies = np.array(frequencies).T
        print(frequencies)
        print(&#34;Building sine waves...&#34;)
        
        # This part of the code takes core
        # of chords, e.g. multiple notes being
        # played at once
        note = np.array([
            np.sin(self.base * frequencies[0] * T * 2 * np.pi)
        ])
        for i in range(1, len(frequencies)):
            note += np.sin(self.base * frequencies[i] * T * 2 * np.pi)
        #################################################################

        print(&#34;Building audio...&#34;)
        # Normalising
        audio = note * (2 ** 15 - 1) / np.max(np.abs(note))
        audio = audio.astype(np.int16)
        print(np.max(audio))
        
        self.audio = audio
        print(&#34;Done!&#34;)
        
        return self.audio
    
    def play(self):
        &#34;&#34;&#34;
        Plays the audio stored in self.audio.
        &#34;&#34;&#34;
        # Start playback
        play_object = sa.play_buffer(self.audio, 1, 2, self.sample_rate)
        # Wait until the audio is finished playing before exiting
        play_object.wait_done()
    
    def save_audio(self, filename: str, no_audio_folder: bool = False) -&gt; str:
        &#34;&#34;&#34;
        Saves the audio stored in self.audio
        to the specified .wav file.
        &#34;&#34;&#34;
        save_location = &#39;&#39;
        if no_audio_folder:
            save_location = filename
        else:
            save_location = f&#34;audio/{filename}&#34;
        
        if &#39;.wav&#39; not in save_location:
            save_location = f&#34;{save_location}.wav&#34;

        # Transposing audio back again so that scipy can write
        # the correct data
        wavfile.write(save_location, self.sample_rate, self.audio.T)
        return save_location
    
    def __repr__(self):
        &#34;&#34;&#34;
        Defines how to show the Player instance
        e.g. when printing it.
        &#34;&#34;&#34;
        return str({
            &#34;scales&#34;: list(self.scales.keys()),
            &#34;audio&#34;: list(self.audio),
            &#34;base&#34;: self.base,
            &#34;sample rate&#34;: self.sample_rate
        })</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Player.Player"><code class="flex name class">
<span>class <span class="ident">Player</span></span>
<span>(</span><span>sample_rate=44100)</span>
</code></dt>
<dd>
<section class="desc"><p>Initializes a Player instance, e.g. player = Player()</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Player(object):
    # 44100 Hz is one of the standard 
    # wav sampling rates, so we default to this
    def __init__(self, sample_rate = 44100):
        &#34;&#34;&#34;
        Initializes a Player instance, e.g. player = Player()
        &#34;&#34;&#34;
        # This function just uses the first digit of the number to decide
        # the scale degree to play
        self.get_note_from_integer = lambda x: int(x[0])
        self.notes = np.array([])
        self.note_durations = np.array([])
        self.duration = 0
        # 83 Hz is the low E on a gutar in standard tuning
        self.base = 83
        self.audio  = np.array([])
        self.sample_rate = sample_rate
        # To get scale tones, we use equal temperament,
        # where each semitone is reached by multiplying
        # the frequency of a pitch by 2^(1/12). This way,
        # an octaver will have exactly twice the frequency,
        # and the notes in between will be (gemoetrically)
        # evenly spaced. Equal temperament is pretty much
        # THE tuning method used in all of Western music.
        # See https://en.wikipedia.org/wiki/Equal_temperament
        # for more information
        self.semitone = 2 ** (1 / 12)
        self.scales = {}
    
        for scale in scales.keys():
            self.add_scale(name=scale, scale=scales[scale])

        # Defaulting the scale to harmonic minor
        self.active_scale = self.scales[&#34;harmonic minor&#34;]

    def set_base(self, base: int):
        &#34;&#34;&#34;
        Sets the base frequency to
        use for new scales.
        &#34;&#34;&#34;
        self.base = base
        return self.base
    
    def set_get_note(self, function: callable):
        &#34;&#34;&#34;
        Sets the get_note_from_integer function. By default,
        this function just uses the first digit in a number,
        but you can change that by passing set_get_note a function.
        &#34;&#34;&#34;
        self.get_note_from_integer = function
        return self.get_note_from_integer

    def update_duration(self):
        &#34;&#34;&#34;
        When we change the notes or
        the note durations, the total
        duration also changes, so we
        must update it. This happens automatically,
        as update_duration is called in both
        set_notes and set_note_durations.
        &#34;&#34;&#34;
        print(f&#34;len(self.note_durations) = {len(self.note_durations)}&#34;)
        self.duration = sum(self.note_durations)
        return self.duration

    def set_notes(self, notes: list):
        &#34;&#34;&#34;
        Sets the player&#39;s notes
        using the given list.
        &#34;&#34;&#34;
        # Making sure all the notes are integers
        self.notes = notes
        # If the length of self.notes and self.note_durations is not
        # the same, then that probably just means you&#39;ve called
        # either set_notes or set_note_durations but not the other
        # We onlyu want to call update_duration if the lengths are the same,
        # because it will (rightfully) throw an error otherwise.
        if len(self.notes) == len(self.note_durations):
            self.update_duration()
        return self.notes
        
    def set_note_durations(self, durations: list):
        &#34;&#34;&#34;
        Uses the given list to set the
        durations of the notes.
        &#34;&#34;&#34;
        # Making sure note durations are floats
        self.note_durations = np.array(durations).astype(float)
        # See the method declaration of set_notes; we only want to call
        # update_duration if self.notes has the same length as 
        # self.note_durations
        if len(self.notes) == len(self.note_durations):
            self.update_duration()
        return self.note_durations

    def set_active_scale(self, name: str):
        &#34;&#34;&#34;
        Sets the active scale to the
        provided scale name, provided
        the scale exists in self.scales
        &#34;&#34;&#34;
        self.active_scale = self.scales[name]
        return self.active_scale

    def add_scale(self, name: str, scale: list, number_of_octaves: int = 100):
        &#34;&#34;&#34;
        Adds a given scale to the Player
        with the given name,
        e.g. Player().add_scale(&#34;melodic minor&#34;, [*scaletones]).
        &#34;&#34;&#34;
        
        # Here we extend the given scale up to many ovtaves.
        # The default is 100 octaves, but we can go higher
        # if we want to. 100 octaves is proably plenty
        # for most use cases though
        extended_scale = np.array(scale)
        for i in range(1, number_of_octaves):
            octave = self.semitone ** (12 * i)
            extended_scale = np.hstack([
                extended_scale, octave * np.array(scale)
            ])
        self.scales[name] = extended_scale
        return extended_scale
    
    def generate_audio(self, scale: list = None):
        &#34;&#34;&#34;
        Uses the given scale, defaulting to self.active_scale,
        to generate audio from self.notes and self.note_durations,
        then stores it in self.audio.
        &#34;&#34;&#34;
        # Make sure there is a note duration
        # specified for each note       
        try:
            len(self.notes) == len(self.note_durations)
        except:
            raise Exception(&#34;self.notes does not have the same length as self.note_durations&#34;)
        # This loop with the try and except
        # allows the user to input single notes
        # without using a list, e.g. 5 instead of [5]
        for i in range(0, len(self.notes)):
            try:
                len(self.notes[i])
            except:
                self.notes[i] = [self.notes[i]]
        # Default the scale to self.active_scale if
        # no scale is given
        if not scale:
            scale = self.active_scale
        T = []
        frequency = []
        intervals = []

        t = 0
        progress = 0
        # Prints like this and others that come up later in this
        # function are just there to give the user an idea
        # of what is going, on, because this function can
        # take a while to run if you give it a lot of data
        print(&#34;Generating t list and intervals...&#34;)

        # Working out the size of the biggest chord used. This
        # will be useful later in the code
        chord_size = max([len(chord) for chord in self.notes])

        for i in range(0, len(self.notes)):
            # Calculate the percentage progress in the loop
            # and print it out if it is more than 1% more than
            # last time we printed it
            new_progress = (i + 1) / len(self.notes) * 100
            if new_progress - progress &gt;= 1:
                progress = new_progress
                print(f&#34;{int(progress)}%&#34;)
            #################################################

            # This is how many &#39;instances&#39; of the note we need to 
            # cover its duration using our sample rate
            n = int(self.sample_rate * self.note_durations[i])
            # Just stick as many notes as we need into the intervals list
            #intervals.extend(np.full(n, self.notes[i]))
            for j in range(0, n):
                intervals.append(self.notes[i])
            # Increment t n times since we added intervals to the intervals list
            for j in range(0, n):
                T.append(t)
                # 1 over the sample rate
                # is the &#39;smallest possible time&#39;
                # for our melody
                t += 1 / self.sample_rate

        T = np.array(T)
        
        print(&#34;Converting scale intervals to frequencies...&#34;)
        chords = [interval if len(interval) &gt; 0 else [interval] for interval in intervals]
        # This loop pads chords that are smaller than the biggest by simply
        # adding a duplicate. This way we can treat all our chords
        # (even single notes!) exactly the samwe way in our code
        for i in range(0, len(chords)):
            chords[i].extend(np.full(chord_size - len(chords[i]), chords[i][0]))
        frequencies = []
        for chord in chords:
                frequency = np.array([scale[interval] for interval in chord])
                frequencies.append(frequency)

        # Transpoing the frequencies. This will make it much
        # easier to merge together the notes in chords
        # Don&#39;t worry about the shape of the array being messed uo
        # now, as we will transpose it back again whenevr
        # we save the audio to a file (in save_audio)
        frequencies = np.array(frequencies).T
        print(frequencies)
        print(&#34;Building sine waves...&#34;)
        
        # This part of the code takes core
        # of chords, e.g. multiple notes being
        # played at once
        note = np.array([
            np.sin(self.base * frequencies[0] * T * 2 * np.pi)
        ])
        for i in range(1, len(frequencies)):
            note += np.sin(self.base * frequencies[i] * T * 2 * np.pi)
        #################################################################

        print(&#34;Building audio...&#34;)
        # Normalising
        audio = note * (2 ** 15 - 1) / np.max(np.abs(note))
        audio = audio.astype(np.int16)
        print(np.max(audio))
        
        self.audio = audio
        print(&#34;Done!&#34;)
        
        return self.audio
    
    def play(self):
        &#34;&#34;&#34;
        Plays the audio stored in self.audio.
        &#34;&#34;&#34;
        # Start playback
        play_object = sa.play_buffer(self.audio, 1, 2, self.sample_rate)
        # Wait until the audio is finished playing before exiting
        play_object.wait_done()
    
    def save_audio(self, filename: str, no_audio_folder: bool = False) -&gt; str:
        &#34;&#34;&#34;
        Saves the audio stored in self.audio
        to the specified .wav file.
        &#34;&#34;&#34;
        save_location = &#39;&#39;
        if no_audio_folder:
            save_location = filename
        else:
            save_location = f&#34;audio/{filename}&#34;
        
        if &#39;.wav&#39; not in save_location:
            save_location = f&#34;{save_location}.wav&#34;

        # Transposing audio back again so that scipy can write
        # the correct data
        wavfile.write(save_location, self.sample_rate, self.audio.T)
        return save_location
    
    def __repr__(self):
        &#34;&#34;&#34;
        Defines how to show the Player instance
        e.g. when printing it.
        &#34;&#34;&#34;
        return str({
            &#34;scales&#34;: list(self.scales.keys()),
            &#34;audio&#34;: list(self.audio),
            &#34;base&#34;: self.base,
            &#34;sample rate&#34;: self.sample_rate
        })</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Player.Player.add_scale"><code class="name flex">
<span>def <span class="ident">add_scale</span></span>(<span>self, name, scale, number_of_octaves=100)</span>
</code></dt>
<dd>
<section class="desc"><p>Adds a given scale to the Player
with the given name,
e.g. Player().add_scale("melodic minor", [*scaletones]).</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_scale(self, name: str, scale: list, number_of_octaves: int = 100):
    &#34;&#34;&#34;
    Adds a given scale to the Player
    with the given name,
    e.g. Player().add_scale(&#34;melodic minor&#34;, [*scaletones]).
    &#34;&#34;&#34;
    
    # Here we extend the given scale up to many ovtaves.
    # The default is 100 octaves, but we can go higher
    # if we want to. 100 octaves is proably plenty
    # for most use cases though
    extended_scale = np.array(scale)
    for i in range(1, number_of_octaves):
        octave = self.semitone ** (12 * i)
        extended_scale = np.hstack([
            extended_scale, octave * np.array(scale)
        ])
    self.scales[name] = extended_scale
    return extended_scale</code></pre>
</details>
</dd>
<dt id="Player.Player.generate_audio"><code class="name flex">
<span>def <span class="ident">generate_audio</span></span>(<span>self, scale=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Uses the given scale, defaulting to self.active_scale,
to generate audio from self.notes and self.note_durations,
then stores it in self.audio.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_audio(self, scale: list = None):
    &#34;&#34;&#34;
    Uses the given scale, defaulting to self.active_scale,
    to generate audio from self.notes and self.note_durations,
    then stores it in self.audio.
    &#34;&#34;&#34;
    # Make sure there is a note duration
    # specified for each note       
    try:
        len(self.notes) == len(self.note_durations)
    except:
        raise Exception(&#34;self.notes does not have the same length as self.note_durations&#34;)
    # This loop with the try and except
    # allows the user to input single notes
    # without using a list, e.g. 5 instead of [5]
    for i in range(0, len(self.notes)):
        try:
            len(self.notes[i])
        except:
            self.notes[i] = [self.notes[i]]
    # Default the scale to self.active_scale if
    # no scale is given
    if not scale:
        scale = self.active_scale
    T = []
    frequency = []
    intervals = []

    t = 0
    progress = 0
    # Prints like this and others that come up later in this
    # function are just there to give the user an idea
    # of what is going, on, because this function can
    # take a while to run if you give it a lot of data
    print(&#34;Generating t list and intervals...&#34;)

    # Working out the size of the biggest chord used. This
    # will be useful later in the code
    chord_size = max([len(chord) for chord in self.notes])

    for i in range(0, len(self.notes)):
        # Calculate the percentage progress in the loop
        # and print it out if it is more than 1% more than
        # last time we printed it
        new_progress = (i + 1) / len(self.notes) * 100
        if new_progress - progress &gt;= 1:
            progress = new_progress
            print(f&#34;{int(progress)}%&#34;)
        #################################################

        # This is how many &#39;instances&#39; of the note we need to 
        # cover its duration using our sample rate
        n = int(self.sample_rate * self.note_durations[i])
        # Just stick as many notes as we need into the intervals list
        #intervals.extend(np.full(n, self.notes[i]))
        for j in range(0, n):
            intervals.append(self.notes[i])
        # Increment t n times since we added intervals to the intervals list
        for j in range(0, n):
            T.append(t)
            # 1 over the sample rate
            # is the &#39;smallest possible time&#39;
            # for our melody
            t += 1 / self.sample_rate

    T = np.array(T)
    
    print(&#34;Converting scale intervals to frequencies...&#34;)
    chords = [interval if len(interval) &gt; 0 else [interval] for interval in intervals]
    # This loop pads chords that are smaller than the biggest by simply
    # adding a duplicate. This way we can treat all our chords
    # (even single notes!) exactly the samwe way in our code
    for i in range(0, len(chords)):
        chords[i].extend(np.full(chord_size - len(chords[i]), chords[i][0]))
    frequencies = []
    for chord in chords:
            frequency = np.array([scale[interval] for interval in chord])
            frequencies.append(frequency)

    # Transpoing the frequencies. This will make it much
    # easier to merge together the notes in chords
    # Don&#39;t worry about the shape of the array being messed uo
    # now, as we will transpose it back again whenevr
    # we save the audio to a file (in save_audio)
    frequencies = np.array(frequencies).T
    print(frequencies)
    print(&#34;Building sine waves...&#34;)
    
    # This part of the code takes core
    # of chords, e.g. multiple notes being
    # played at once
    note = np.array([
        np.sin(self.base * frequencies[0] * T * 2 * np.pi)
    ])
    for i in range(1, len(frequencies)):
        note += np.sin(self.base * frequencies[i] * T * 2 * np.pi)
    #################################################################

    print(&#34;Building audio...&#34;)
    # Normalising
    audio = note * (2 ** 15 - 1) / np.max(np.abs(note))
    audio = audio.astype(np.int16)
    print(np.max(audio))
    
    self.audio = audio
    print(&#34;Done!&#34;)
    
    return self.audio</code></pre>
</details>
</dd>
<dt id="Player.Player.play"><code class="name flex">
<span>def <span class="ident">play</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Plays the audio stored in self.audio.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def play(self):
    &#34;&#34;&#34;
    Plays the audio stored in self.audio.
    &#34;&#34;&#34;
    # Start playback
    play_object = sa.play_buffer(self.audio, 1, 2, self.sample_rate)
    # Wait until the audio is finished playing before exiting
    play_object.wait_done()</code></pre>
</details>
</dd>
<dt id="Player.Player.save_audio"><code class="name flex">
<span>def <span class="ident">save_audio</span></span>(<span>self, filename, no_audio_folder=False)</span>
</code></dt>
<dd>
<section class="desc"><p>Saves the audio stored in self.audio
to the specified .wav file.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_audio(self, filename: str, no_audio_folder: bool = False) -&gt; str:
    &#34;&#34;&#34;
    Saves the audio stored in self.audio
    to the specified .wav file.
    &#34;&#34;&#34;
    save_location = &#39;&#39;
    if no_audio_folder:
        save_location = filename
    else:
        save_location = f&#34;audio/{filename}&#34;
    
    if &#39;.wav&#39; not in save_location:
        save_location = f&#34;{save_location}.wav&#34;

    # Transposing audio back again so that scipy can write
    # the correct data
    wavfile.write(save_location, self.sample_rate, self.audio.T)
    return save_location</code></pre>
</details>
</dd>
<dt id="Player.Player.set_active_scale"><code class="name flex">
<span>def <span class="ident">set_active_scale</span></span>(<span>self, name)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the active scale to the
provided scale name, provided
the scale exists in self.scales</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_active_scale(self, name: str):
    &#34;&#34;&#34;
    Sets the active scale to the
    provided scale name, provided
    the scale exists in self.scales
    &#34;&#34;&#34;
    self.active_scale = self.scales[name]
    return self.active_scale</code></pre>
</details>
</dd>
<dt id="Player.Player.set_base"><code class="name flex">
<span>def <span class="ident">set_base</span></span>(<span>self, base)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the base frequency to
use for new scales.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base(self, base: int):
    &#34;&#34;&#34;
    Sets the base frequency to
    use for new scales.
    &#34;&#34;&#34;
    self.base = base
    return self.base</code></pre>
</details>
</dd>
<dt id="Player.Player.set_get_note"><code class="name flex">
<span>def <span class="ident">set_get_note</span></span>(<span>self, function)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the get_note_from_integer function. By default,
this function just uses the first digit in a number,
but you can change that by passing set_get_note a function.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_get_note(self, function: callable):
    &#34;&#34;&#34;
    Sets the get_note_from_integer function. By default,
    this function just uses the first digit in a number,
    but you can change that by passing set_get_note a function.
    &#34;&#34;&#34;
    self.get_note_from_integer = function
    return self.get_note_from_integer</code></pre>
</details>
</dd>
<dt id="Player.Player.set_note_durations"><code class="name flex">
<span>def <span class="ident">set_note_durations</span></span>(<span>self, durations)</span>
</code></dt>
<dd>
<section class="desc"><p>Uses the given list to set the
durations of the notes.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_note_durations(self, durations: list):
    &#34;&#34;&#34;
    Uses the given list to set the
    durations of the notes.
    &#34;&#34;&#34;
    # Making sure note durations are floats
    self.note_durations = np.array(durations).astype(float)
    # See the method declaration of set_notes; we only want to call
    # update_duration if self.notes has the same length as 
    # self.note_durations
    if len(self.notes) == len(self.note_durations):
        self.update_duration()
    return self.note_durations</code></pre>
</details>
</dd>
<dt id="Player.Player.set_notes"><code class="name flex">
<span>def <span class="ident">set_notes</span></span>(<span>self, notes)</span>
</code></dt>
<dd>
<section class="desc"><p>Sets the player's notes
using the given list.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_notes(self, notes: list):
    &#34;&#34;&#34;
    Sets the player&#39;s notes
    using the given list.
    &#34;&#34;&#34;
    # Making sure all the notes are integers
    self.notes = notes
    # If the length of self.notes and self.note_durations is not
    # the same, then that probably just means you&#39;ve called
    # either set_notes or set_note_durations but not the other
    # We onlyu want to call update_duration if the lengths are the same,
    # because it will (rightfully) throw an error otherwise.
    if len(self.notes) == len(self.note_durations):
        self.update_duration()
    return self.notes</code></pre>
</details>
</dd>
<dt id="Player.Player.update_duration"><code class="name flex">
<span>def <span class="ident">update_duration</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>When we change the notes or
the note durations, the total
duration also changes, so we
must update it. This happens automatically,
as update_duration is called in both
set_notes and set_note_durations.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_duration(self):
    &#34;&#34;&#34;
    When we change the notes or
    the note durations, the total
    duration also changes, so we
    must update it. This happens automatically,
    as update_duration is called in both
    set_notes and set_note_durations.
    &#34;&#34;&#34;
    print(f&#34;len(self.note_durations) = {len(self.note_durations)}&#34;)
    self.duration = sum(self.note_durations)
    return self.duration</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Player.Player" href="#Player.Player">Player</a></code></h4>
<ul class="two-column">
<li><code><a title="Player.Player.add_scale" href="#Player.Player.add_scale">add_scale</a></code></li>
<li><code><a title="Player.Player.generate_audio" href="#Player.Player.generate_audio">generate_audio</a></code></li>
<li><code><a title="Player.Player.play" href="#Player.Player.play">play</a></code></li>
<li><code><a title="Player.Player.save_audio" href="#Player.Player.save_audio">save_audio</a></code></li>
<li><code><a title="Player.Player.set_active_scale" href="#Player.Player.set_active_scale">set_active_scale</a></code></li>
<li><code><a title="Player.Player.set_base" href="#Player.Player.set_base">set_base</a></code></li>
<li><code><a title="Player.Player.set_get_note" href="#Player.Player.set_get_note">set_get_note</a></code></li>
<li><code><a title="Player.Player.set_note_durations" href="#Player.Player.set_note_durations">set_note_durations</a></code></li>
<li><code><a title="Player.Player.set_notes" href="#Player.Player.set_notes">set_notes</a></code></li>
<li><code><a title="Player.Player.update_duration" href="#Player.Player.update_duration">update_duration</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>